<!DOCTYPE html>
<html lang="en" style="overflow-y: scroll; margin-bottom: 0">
<head>
    <meta charset="UTF-8">
    <title>MUTGOS Demo Web Client</title>

    <!-- Open all links in new tabs. -->
    <!-- <base target="_blank" /> -->

<style type="text/css">

html, body, .flex_container {
    height: 100%;
    display: flex;
    flex-direction: column;
}

.flex_container {
    display:flex;
    flex-flow: column nowrap;
}

.flex_fixed_child {
    flex:none;
}

.flex_expand_child {
    flex:auto;
}

.no-underline-link {
    text-decoration: none;
}

.output-area {
    overflow: auto;
    font-family: "Lucida Console", Monaco, monospace;
    font-size: medium;
    background-color: black;
    color: white;
}

.input-line {
    width: 100%;
    background-color: DarkSlateBlue;
    border-top: 5px solid black;
    position: sticky;
    bottom: 0;
    left: 0;
    right: 0;
}

.input-field {
    background: transparent;
    color: White;
    border-style: none;
    width: 84%;
    font-family: "Lucida Console", Monaco, monospace;
    font-size: medium;
}

.submit-button {
    width: 9%;
    min-width: 2%;
    vertical-align: top;
}

.prev-button {
    width: 5%;
    min-width: 1%;
    vertical-align: top;
}

.mutgosRecvText {
    word-wrap: break-word;
    white-space: pre-wrap;       /* css-3 */
}

.output-input-pair-inactive {
/**    position: fixed; */
    left: 0;
    top: 0;
    width: 100%;
    z-index: 1;
    display: none;
}

.output-input-pair-active {
    /**    position: fixed; */
    left: 0;
    top: 0;
    width: 100%;
    z-index: 2;
    display: inherit;
}

/** Modal stuff adapted from https://www.w3schools.com/howto/tryit.asp?filename=tryhow_css_modal */

    /* The Modal (background) */
.modal {
    display: block;
    position: fixed; /* Stay in place */
    z-index: 100; /* Sit on top */
    padding-top: 100px; /* Location of the box */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgb(0,0,0); /* Fallback color */
    background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
}

/* Modal Content */
.modal-content {
    background-color: #fefefe;
    margin: auto;
    padding: 20px;
    border: 1px solid #888;
    width: 80%;
}

/* Modal Content for white text */
.modal-content-black {
    background-color: #000000;
    color: white;
    margin: auto;
    padding: 20px;
    border: 1px solid #FFFFFF;
    width: 80%;
}

/* Puppet chooser modal */
.puppet-chooser-modal {
    background-color: #000000;
    color: white;
    link: white;
    vlink: white;
    alink: white;
    margin: auto;
    padding: 20px;
    border: 1px solid #FFFFFF;
    width: 50%;
    height: 70%;
}

/* Entity tab coloring for active tab */
.active-entity-tab {
    background-color: #777777;
    color: white;
    link: white;
}

/* Entity tab coloring for inactive tab */
.inactive-entity-tab {
    background-color: black;
    color: lightgray;
    link: lightgray;
}

/* The Close Button */
.close {
    color: #cccccc;
    float: right;
    font-size: 28px;
    font-weight: bold;
}

.close:hover,
.close:focus {
    color: #000;
    text-decoration: none;
    cursor: pointer;
}

</style>

    <script type="text/javascript" src="../third_party/vue.js"></script>

    <script type="text/javascript" src="../wsinterface/RawTextgameProtocolClient.js"></script>
    <script type="text/javascript" src="../wsinterface/DataTypes.js"></script>
    <script type="text/javascript" src="../wsinterface/TextgameProtocolClient.js"></script>

    <script type="text/javascript" src="FormattedTextComponent.js"></script>
</head>
<body alink="#ffff00"
      link="#eeee00" style="background-color: black; margin-bottom: 0" vlink="#eeee00">
<div class="flex_container" id="app">
    <!-- The login modal dialog -->
    <div v-if="! connectionState.authenticated" id="loginDialog" class="modal">
        <!-- Modal content -->
        <div class="modal-content" style="width: 50%;">
            <select id = "siteList" v-model="connectionState.site">
                <option value="-1">Select a site</option>
                <option v-for="site in siteList" v-bind:value="site.id">
                    {{ site.id }} - {{ site.name }} ({{ site.description }})
                    {{ site.onlineCount }} online
                </option>
            </select>
            <p/>
            <input v-model="connectionState.username"
                   placeholder="Username">

            <input type="password" v-model="connectionState.password"
                   placeholder="Password">
            <p/>
            <div style="color: red">
                {{ connectionState.authenticationMessage }}
            </div>
            <p/>
            <button v-on:click="submitAuthentication"
                    v-bind:disabled="connectionState.authenticationInProgress">
                ‚úîÔ∏è Login
            </button>
        </div>
    </div>

    <!-- The description modal dialog -->
    <div v-if="descriptionData.descriptionReceived"
         id="descriptionDialog"
         class="modal">
        <!-- Modal content -->
        <div class="modal-content-black">
            <span class="close" v-on:click="closeDescription">&times;</span>
            <formatted-text-line
                    v-for="descId in descriptionData.descriptionIds"
                    v-bind:external-text-id="descId"
                    external-text-topic="descOutput"
                    class="mutgosRecvText">
            </formatted-text-line>
        </div>
    </div>

    <!-- The puppet select dialog -->
    <div class="modal"
         id="addPuppetTabDialog"
         v-if="puppetQueryInfo.puppetsReceived">
        <!-- Modal content -->
        <div class="puppet-chooser-modal">
            <span class="close" v-on:click="closeAddPuppet">&times;</span>
            <div v-for="puppetInfo in puppetQueryInfo.puppetList">
                <!-- Note that puppetID is the entity ID portion only, not the site -->
                <a :puppetId="puppetInfo.id.entityId" :puppetName="puppetInfo.name"
                   href="javascript:void(0);" v-on:click="addPuppetFromDialog">
                    {{puppetInfo.name}}
                </a>
                <br/>
            </div>
        </div>
    </div>

    <div class="flex_expand_child"></div>

    <!-- The input/output/puppet selection for each tab -->
    <div class="flex_fixed_child" v-for="(topicInfo, topicName) in entityTabInfo">
        <div v-bind:class=
                 "topicName === activeTopic.name ? 'output-input-pair-active' : 'output-input-pair-inactive'">
            <div class="output-area" style="background-color: black;">
                <formatted-text-line
                        :external-text-topic="topicName"
                        class="mutgosRecvText"
                        v-bind:external-text-id="outputId"
                        v-for="outputId in outputIds[topicName]">
                </formatted-text-line>
            </div>
            <div class="input-line">
                <textarea :id="topicName + '-input-field'"
                          @keydown="submitEnter"
                          class="input-field"
                          placeholder="Input Line"
                          rows="1"
                          style="resize: none;"
                          v-bind:disabled=
                                  "(! connectionState.established) || connectionState.blocked"
                          v-model="inputLineData[topicName].inputLine"></textarea>
                <button class="submit-button"
                        title=
                                "Sends text to server"
                        v-bind:disabled=
                                "(! connectionState.established) || connectionState.blocked"
                        v-on:click="submitText">
                    {{ displayState.sendButtonName }}
                </button>
                <button class="prev-button"
                        title=
                                "See last text sent to server, only when input line is empty"
                        v-bind:disabled=
                                "(! connectionState.established) || connectionState.blocked"
                        v-on:click="goPreviousInput">
                    üîô Prev
                </button>

                <!-- Add the tab bar on the bottom to select puppet/player -->
                <div style="color: white; background: black">
                    <!-- Activity indicator for player -->
                    <span v-bind:style="entityTabInfo.PLAYER.activity ? 'color: chartreuse;' : 'color: black;'">
                        ‚ú∑
                    </span>
                    <!-- Tab name -->
                    <a href="javascript:void(0);" style="text-decoration: none;"
                       topicName="PLAYER"
                       v-bind:class= "('PLAYER' === activeTopic.name ? 'active-entity-tab' : 'inactive-entity-tab')"
                       v-on:click="switchToEntityTab">{{ entityTabInfo.PLAYER.name }}</a>
                    <!-- Separator -->
                    ‚îÉ

                    <span v-for="(topicInfo, topicName) in entityTabInfo">
                        <!-- Activity indicator for puppet -->
                        <span v-bind:style="topicInfo.activity ? 'color: chartreuse;' : 'color: black;'"
                             v-if="topicName !== 'PLAYER'">
                            ‚ú∑
                        </span>
                        <a :topicName="topicName" href="javascript:void(0);"
                           style="text-decoration: none;"
                           v-bind:class= "topicName === activeTopic.name ? 'active-entity-tab' : 'inactive-entity-tab'"
                           v-if="topicName !== 'PLAYER'"
                           v-on:click="switchToEntityTab">{{ topicInfo.name }}</a>
                        <!-- Can't close the player tab -->
                        <a :topicName="topicName"
                           href="javascript:void(0);"
                           style="link: red; vlink: red; alink: red; text-decoration: none;" v-if="topicName !== 'PLAYER'"
                           v-on:click="closeEntityTab"> ‚ìç </a>
                        <!-- Separator -->
                        <span v-if="topicName !== 'PLAYER'">‚îÉ</span>
                    </span>

                    <!-- Add puppet button -->
                    <a href="javascript:void(0);"
                       style="text-decoration: none;"
                       v-on:click="submitPuppetListQuery">
                        [+]
                    </a>
                </div>

            </div>
        </div>
    </div>
</div>






<script>

    // Constant for the player output topic, which also serves as the console
    var PLAYER_TOPIC = 'PLAYER';

    // Global used to identify which tab is selected.  This would correspond to
    // the topics in outputTextStore.
    activeTopic = {};
    activeTopic.name = PLAYER_TOPIC;
    // This global is used by FormattedTextComponent to access
    // ExternalText for lines output from the server.  At the top level, it is
    // separated by topic, such as the main player tab, description popup,
    // puppets, etc.  From there, it's a map (discontinuous array) of numeric
    // ID to an array of external text that represents a line.
    outputTextStore = {};

    //
    // Shared variables between Vue application and the protocol interface
    //

    var DESCRIPTION_SUBTYPE = "DESCRIPTION";
    var CLIENT_DATA_SUBTYPE = "ClientData";
    var PUPPET_CHANNEL_PREFIX = "Puppet ";
    var PUPPET_CLIENT_DATA_SUBTYPE = PUPPET_CHANNEL_PREFIX + CLIENT_DATA_SUBTYPE;
    var PUPPET_AGENT_TYPE = PUPPET_CHANNEL_PREFIX + "Agent";

    var connectionUrl = "ws://" + window.location.hostname + ":7000/localhost/127.0.0.1";

    // Used with outputTextStore as the ID for a line of ExternalText.
    var nextOutputId = 1;
    // Used when making requests, this is the next request serial number
    var nextRequestId = 1;

    // Maps topic name to array of text line IDs.
    // Array Index 0 is top of the screen.  This is composed of IDs (that link
    // into outputTextStore) that can be pushed on and removed to trigger Vue
    // to update the screen.  The order the IDs appear here will determine the
    // order they appear on the screen.
    // See outputTextStore for the actual text.
    var outputIds = {};
    var siteList = [];
    var connectionState = {
        established : false,
        authenticated : false,
        authenticationInProgress : false,
        authenticationMessage : '',
        username : '',
        password : '',
        site : -1,
        siteName : ''
    };
    var entityDescription = {
        descriptionChannel : null,
        descriptionReceived : false,
        // Like outputIds, this has just the IDs, to indicate the order
        // ExternalText should appear.
        // See outputTextStore.descOutput for the actual text.
        descriptionIds : [],
        // Request ID for finding the look program
        requestId : 0,
        // ID of the look program
        lookId : null
    };
    var displayState = {
        hasFocus : true,
        textAdded : false,
        sendButtonName: "‚úîÔ∏è Send"
    };

    // Maps channel ID (number) to topic name (string)
    var channelIdToTopic = new Map();

    // Maps topic name to info about an open tab, such as
    // open channels, name, etc.
    // Each entry has this contents:
    // // True if blocked
    // blocked : true,
    //
    // // Maps topic to its control channels.
    // // The value has this  contents:
    // // {
    // //  /** {SendChannel} */
    // //  send : null,
    // //  /** {ReceiveChannel} */
    // //  receive : null
    // // };
    // controlChannels : {},
    //
    // // Array of active input channels basically as a stack.
    // // Frontmost item (index 0) is where user input goes to.
    // inputStack = {};
    //
    // // Name of the player/puppet on the tab.
    // name : ""
    //
    var entityTabInfo = {};

    // Key is topic, value is object:
    //  inputLine: String that is current input in input field
    //  prevInputLines: Array of strings for previous input
    //  prevLineIndex: Number indicating which prevInputLine is selected
    var inputLineData  = {};

    // The initial title of this HTML Document
    var origTitle = document.title;
    var siteName = "";
    var playerName = "";
    // Current location of player
    var locationName = "";

    var puppetQueryInfo = {
        puppetsReceived : false,
        // The request ID
        requestId : 0,
        // List of puppets returned from query request.
        // Each entry has two attributes: 'id' and 'name'
        puppetList : []
    };

    var protocol = new TextgameProtocolClient();


    /**
     * Sets the title for the document, whether or not it's in focus.
     * This is normally not called directly by client code.
     * @param {string} newTitle The new title for the document.
     */
    var setTitle = function(newTitle) {
        origTitle = newTitle;

        if (! displayState.hasFocus) {
            document.title = "[! ACTIVITY DETECTED !] " + origTitle;
        } else {
            document.title = origTitle;
        }
    };

    /**
     * Sets the player name on the title.
     * @param {string} newPlayerName The new name of the player or puppet
     */
    var setTitlePlayerName = function(newPlayerName) {
        playerName = newPlayerName;
        setTitle(siteName + ": " + playerName + "  /  " + locationName);
    };

    /**
     * Sets the site name on the title.
     * @param {string} newSiteName The new name of the site
     */
    var setTitleSiteName = function(newSiteName) {
        siteName = newSiteName;
        setTitle(siteName + ": " + playerName + "  /  " + locationName);
    };

    /**
     * Sets the location name on the title.
     * @param {string} newLocationName The new location name.
     */
    var setTitleLocationName = function(newLocationName) {
        locationName = newLocationName;
        setTitle(siteName + ": " + playerName + "  /  " + locationName);
    };

    /**
     * Identifiers do eventually wrap.
     * @return {number} The next identifier to map a line of ExternalText.
     */
    var getNextId = function() {
        if (nextOutputId >= (Number.MAX_VALUE - 1)) {
            nextOutputId = 1;
        }

        return nextOutputId++;
    };

    /**
     * Identifiers do eventually wrap.
     * @return {number} The next identifier for a request
     */
    var getNextRequestId = function() {
        if (nextRequestId >= 4294967290) {
            nextRequestId = 1;
        }

        return nextRequestId++;
    };

    /**
     * Gets the topic name from a channel ID
     * @param {number} id The ID of the channel.
     * @return {string} The topic name
     */
    var getTopicNameFromId = function (id) {
        if (id === -1) {
            // -1 means 'console', or the player output
            return PLAYER_TOPIC;
        }
        else {
            return channelIdToTopic.get(id);
        }
    };

    //
    // Protocol interface methods and initial setup.
    //

    /**
     * Adds text from an incoming channel to a tab
     * @param {number} id The ID of the channel sending the text, or -1
     * for 'console' / player output.
     * @param {ExternalText} formattedText The line of formatted to add.
     */
    var addIncomingText = function(id, formattedText) {
        var newId = getNextId();
        var topicName = getTopicNameFromId(id);

        if (topicName === undefined) {
            // Maybe this came in after cleanup due to timing?
            // Ignore.
            return;
        }

        var outputIdForTopic = outputIds[topicName];
        var outputStoreForTopic = outputTextStore[topicName];

        // Add new line
        //
        outputStoreForTopic[newId] = formattedText;
        outputIdForTopic.push(newId);

        // Remove an old line if we've hit our limit.
        //
        if (outputIdForTopic.length > 3000) {
            var removedId = outputIdForTopic.shift();
            Vue.delete(outputStoreForTopic.playerOutput, removedId);
        }

        if (activeTopic.name !== topicName) {
            entityTabInfo[topicName].activity = true;
        }

        if ((! displayState.hasFocus) && (! displayState.textAdded)) {
            displayState.textAdded = true;
            document.title = "[! ACTIVITY DETECTED !] " + origTitle;
        }

        setTimeout(function() {
            window.scrollBy(0,10000);
        }, 15);
    };

    /**
     * Adds alert text to the output portion of the screen.
     * @param {string} alertText The text to add.
     */
    var addAlert = function(alertText) {
        var formatted = new ExternalFormattedText("---" + alertText);
        formatted.color = formatted.ColorEnum.RED;
        formatted.bold = true;

        addIncomingText(-1, {textLine: [formatted]});
    };

    /**
     * Adds text for a description.
     * @param {number} id The ID of the channel sending the text
     * @param {ExternalText} formattedText The line of formatted to add.
     */
    var addIncomingDescText = function(id, formattedText) {
        var newId = getNextId();
        entityDescription.descriptionIds.push(newId);
        outputTextStore.descOutput[newId] = formattedText;
    };

    /**
     * Called when the description channel's status has changed.  Used
     * to indicate the description can be displayed to the user.
     * @param {number} id The ID of the channel.
     * @param {string} status The new Channel status.
     */
    var processDescChannelStatus = function(id, status) {
        if (status === entityDescription.descriptionChannel.ChannelStatusEnum.CLOSE) {
            // Full description received.  Let UI know.
            //
            entityDescription.descriptionReceived = true;
            entityDescription.descriptionChannel = null;
        }
    };

    /**
     * Called when either client data channel status changes for players; this
     * lets us know when it is safe to send a request.  This is used to send
     * the 'look' command upon login.
     * @param {number} id The ID of the channel.
     * @param {string} status The new Channel status.
     */
    var processClientDataChannelStatus = function(id, status) {
        var bothChannelsGood = true;
        var topicName = getTopicNameFromId(id);

        if (topicName === undefined) {
            // Maybe this came in after cleanup due to timing?
            // Ignore.
            return;
        }

        var info = entityTabInfo[topicName];
        var controlChannelForTopic = info.controlChannels;

        if ((controlChannelForTopic.receive === null) ||
            (controlChannelForTopic.send === null)) {
            bothChannelsGood = false;
        }

        if (bothChannelsGood) {
            if (! (controlChannelForTopic.receive.isOpen() &&
               (! controlChannelForTopic.receive.isBlocked()) &&
                controlChannelForTopic.send.isOpen() &&
               (! controlChannelForTopic.send.isBlocked()))) {
                bothChannelsGood = false;
            }
        }

        if ((entityDescription.lookId === null) && bothChannelsGood) {
            // We have both channels and they are open.  Send the request for
            // the 'look' command if we haven't already.
            //
            var findLook = protocol.makeClientMessage("FindEntityRequest");

            findLook.requestMessageId = getNextRequestId();
            findLook.isMessageResponse = false;
            findLook.searchString = "look";
            findLook.exactMatch = true;
            findLook.entityType = "action";

            entityDescription.requestId = findLook.requestMessageId;

            controlChannelForTopic.send.sendData(findLook);
        }
    };

    /**
     * Called when client data is recieved.
     * For the demo, this simply processes the result for finding the 'look'
     * action.
     * @param {number} id The ID of the channel.
     * @param {Object} data The client data.
     */
    var receiveClientData = function(id, data) {
        var topicName = getTopicNameFromId(id);

        if (topicName === undefined) {
            // Maybe this came in after cleanup due to timing?
            // Ignore.
            return;
        }

        // We only support find result, location changes, and list of puppets
        // right now
        //
        if (data.messageType === "FindEntityResult") {
            if (data.requestMessageId === entityDescription.requestId) {
                if (data.securityViolation) {
                    addAlert("Unable to get look command info due to security violation.");
                } else if (data.ambiguous) {
                    addAlert("Unable to get look command info due to ambiguous lookup.");
                } else if (data.result) {
                    if (data.result.length <= 0) {
                        addAlert("Did not return any matching IDs for look");
                    } else {
                        if (data.result.length > 1) {
                            addAlert("More than one action ID returned for look.");
                        }

                        entityDescription.lookId = data.result[0].id;
                    }
                } else {
                    addAlert("Did not return result for look");
                }
            } else if (data.requestMessageId === puppetQueryInfo.requestId) {
                puppetQueryInfo.puppetList = [];

                if (data.securityViolation) {
                    addAlert("Unable to get puppet list due to security violation.");
                } else if (data.ambiguous) {
                    addAlert("Unable to get puppet list due to ambiguous lookup.");
                } else if (data.result) {
                    if (data.result.length <= 0) {
                        addAlert("Did not return any puppets.  Create some puppets first.");
                    } else {
                        for (index = 0; index < data.result.length; ++index) {
                            var foundPuppet = data.result[index];

                            if (entityTabInfo.hasOwnProperty(
                                "" + foundPuppet.id.entityId)) {
                                // Puppet already in tabs, skip
                                continue;
                            }

                            var puppetEntry =
                                {id: foundPuppet.id, name: foundPuppet.name };
                            puppetQueryInfo.puppetList.push(puppetEntry);
                        }

                        puppetQueryInfo.puppetsReceived = true;
                    }
                } else {
                    addAlert("Did not return result for puppet list query");
                }
            }
        } else if (data.messageType === "LocationInfoChange") {
            if (topicName !== PLAYER_TOPIC) {
                // Right now only setting the title for players; puppets
                // won't show location changes on the titlebar.
                return;
            }

            if (data.newRoomId) {
                // We changed rooms.  Accept the room name even if empty.
                //
                if (data.newRoomName) {
                    setTitleLocationName(data.newRoomName);
                } else {
                    setTitleLocationName("");
                }
            } else if (data.newRoomName) {
                // We did not change rooms, but the name changed.
                //
                setTitleLocationName(data.newRoomName);
            }
        }
    };

    /**
     * Called when the connection has been established, it will also request
     * the site list and authenticate, as needed.
     */
    var connectionGood = function(){
        displayState.sendButtonName = "‚úîÔ∏è Send";
        connectionState.established = true;

        // Prompt if they are sure they want to leave
        window.onbeforeunload = function() {
            return true;
        };

        // If we haven't authenticated yet, request the site list or initiate
        // authentication.
        //
        if (! connectionState.authenticated) {
            if (siteList.length <= 0) {
                protocol.requestSiteList();
            } else if (connectionState.authenticationInProgress) {
                // Send authentication
                protocol.authenticate(
                    connectionState.username,
                    connectionState.password,
                    connectionState.site);
            }
        }
    };

    protocol.onConnectionEstablished = connectionGood;
    protocol.onReconnected = connectionGood;

    protocol.onLostConnection = function() {
        displayState.sendButtonName = "üïí RECONNECTING";
        connectionState.established = false;
    };

    protocol.onDisconnection = function() {
        displayState.sendButtonName = "‚õîÔ∏è Disconnected";
        connectionState.established = false;

        if (connectionState.authenticated) {
            addAlert("Disconnected from server");
        }

        window.onbeforeunload = null;

        if (connectionState.authenticated) {
            setTitle("DISCONNECTED: " + origTitle);
        }
    };

    protocol.onError = function(errorText) {
        addAlert(errorText);
    };

    protocol.onAuthenticationSuccess = function() {
        connectionState.authenticated = true;
        connectionState.authenticationInProgress = false;
        connectionState.authenticationMessage = "";

        setTitleSiteName(connectionState.siteName);
        setTitlePlayerName(connectionState.username);
        entityTabInfo.PLAYER.name = connectionState.username;

        connectionState.password = undefined;
    };

    protocol.onAuthenticationFail = function() {
        connectionState.authenticated = false;
        connectionState.authenticationInProgress = false;
        connectionState.password = "";
        connectionState.authenticationMessage =
            "Failed to login.  Check your site, username, and password.";

        protocol.disconnect();
    };

    protocol.onSiteList = function(sites) {
        if (siteList.length > 0) {
            siteList.splice(0, siteList.length);
        }

        for (var index = 0; index < sites.length; ++index) {
            siteList.push(sites[index]);
        }

        // Disconnect immediately, since it will likely be a few moments
        // for the user to pick a site and type in credentials.
        // This simplifies things as the server will disconnect us soon anyway.
        //
        protocol.disconnect();
    };

    /**
     * Handles channels when they get open, and puts them in the right place
     * to send/receive data.
     * @param {Channel} channel The channel being opened.
     */
    protocol.onChannelOpen = function(channel) {
        // Gets/Creates a mapping for channelID to topic name
        //
        var topicName;

        if (channel.entityId && (channel.entityId.entityId > 0)) {
            // Puppet channel.  Topic may not exist; create as needed
            //
            topicName = "" + channel.entityId.entityId;

            if (! outputTextStore.hasOwnProperty(topicName)) {
                // New topic; need to add data structures.
                Vue.set(outputTextStore, topicName, []);
                Vue.set(outputIds, topicName, []);
                Vue.set(entityTabInfo, topicName, {
                    blocked : true,
                    activity: false,
                    controlChannels : {
                        /** {SendChannel} */
                        send : null,
                        /** {ReceiveChannel} */
                        receive : null
                    },
                    inputStack : [],
                    name : channel.subtype
                });
                Vue.set(inputLineData, topicName, {
                    inputLine: "",
                    prevInputLines: [],
                    prevLineIndex: []
                });

                // Make sure we re-focus on text box after tabs update
                //
                if (document.activeElement && document.activeElement.id) {
                    var activeId = document.activeElement.id;

                    if (activeId) {
                        setTimeout(function() {
                            var activeElement = document.getElementById(
                                activeId);
                            activeElement.focus();
                        }, 1);
                    }
                }
            }
        } else {
            // Player channel.  Topic already created so just add mapping
            topicName = PLAYER_TOPIC;
        }

        channelIdToTopic.set(channel.id, topicName);
        var info = entityTabInfo[topicName];

        if (channel instanceof SendChannel) {
            // Send channels just get added to the stack for the given topic's
            // channels, except the client data channel.
            //
            if (channel.name === PUPPET_CLIENT_DATA_SUBTYPE) {
                info.controlChannels.send = channel;
            }
            else if (channel.name === CLIENT_DATA_SUBTYPE) {
                info.controlChannels.send = channel;
                // Need status change so we can retrieve additional information
                // from server
                channel.onStatusChange = processClientDataChannelStatus;
            } else {
                // This will listen and interpret Channel status, changing
                // blocked status or removing it from the inputStack as needed.
                //
                info.inputStack.splice(0, 0, channel);

                channel.onStatusChange = function(id, status) {
                    var topicName = getTopicNameFromId(id);

                    if (topicName === undefined) {
                        // Maybe this came in after cleanup due to timing?
                        // Ignore.
                        return;
                    }

                    var inputStackForTopic = info.inputStack;

                    if ((status === channel.ChannelStatusEnum.BLOCK) &&
                        (inputStackForTopic.length > 0) &&
                        (inputStackForTopic[0] === channel)) {
                        // We're blocked and the top channel.  Disable input
                        info.blocked = true;
                    } else if ((status === channel.ChannelStatusEnum.UNBLOCK) &&
                        (inputStackForTopic.length > 0) &&
                        (inputStackForTopic[0] === channel)) {
                        // We're not blocked and the top channel.  Enable input
                        info.blocked = false;
                    } else if (status === channel.ChannelStatusEnum.CLOSE) {
                        // Channel has closed.  Remove from stack and update
                        // blocked status as needed.
                        //
                        var foundIndex = inputStackForTopic.indexOf(channel);

                        if (foundIndex >= 0) {
                            inputStackForTopic.splice(foundIndex, 1);
                        }

                        if (inputStackForTopic.length > 0) {
                            info.blocked = inputStackForTopic[0].isBlocked();
                        } else {
                            // No channels left, for the moment.  Block.
                            info.blocked = true;
                        }
                    }
                };


                if (channel.isBlocked()) {
                    info.blocked = true;
                }
            }
        } else {
            // Receive channels get listeners added so they appear on the main
            // screen.  Unless it's a description channel, then it gets routed
            // to the description popup.  ... Or a client data channel.
            //
            if (channel.name === PUPPET_CLIENT_DATA_SUBTYPE) {
                // Currently we don't use this. Just store for now.
                info.controlChannels.receive = channel;
            }
            else if (channel.name === CLIENT_DATA_SUBTYPE) {
                info.controlChannels.receive = channel;
                // Need status change so we can retrieve additional information
                // from server
                channel.onStatusChange = processClientDataChannelStatus;
                channel.onReceiveData = receiveClientData;
            } else {
                // Check subtype.  If desc, link up to desc stuff
                if (channel.subtype === DESCRIPTION_SUBTYPE) {
                    // Only add and prepare for display if a description is not
                    // already in progress, otherwise ignore.
                    if (entityDescription.descriptionChannel === null) {
                        entityDescription.descriptionChannel = channel;

                        entityDescription.descriptionIds.splice(
                            0,
                            entityDescription.descriptionIds.length);
                        outputTextStore.descOutput.splice(
                            0,
                            outputTextStore.descOutput.length);

                        entityDescription.descriptionReceived = false;
                        channel.onStatusChange = processDescChannelStatus;
                        channel.onReceiveTextData = addIncomingDescText;
                    }
                } else {
                    // Standard receive (incoming text) channel.
                    channel.onReceiveTextData = addIncomingText;
                    // Add cleanup for when it closes
                    channel.onStatusChange = function(id, status) {
                        if (status === channel.ChannelStatusEnum.CLOSE) {
                            // Channel has been closed. Remove from lookup
                            channelIdToTopic.delete(id);
                        }
                    };
                }
            }
        }
    };




    //
    // Vue application code
    //

    // Register components.
    //
    mutgos_registerFormattedTextComponent();

    var mutgosClient = new Vue({
        el: "#app",
        data: {
            // Constants
            PLAYER_TOPIC : PLAYER_TOPIC,

            // Which tab is active
            activeTopic : activeTopic,
            // Lines to appear in each tab, organized by topic name
            outputIds : outputIds,
            // Where all the output text is kept
            outputTextStore : outputTextStore,
            inputLineData : inputLineData,
            displayState : displayState,
            entityTabInfo : entityTabInfo,
            puppetQueryInfo : puppetQueryInfo,

            // Authentication flags and related data
            //
            connectionState : connectionState,
            siteList : siteList,

            // Display of Entity description data
            descriptionData : entityDescription
        },
        methods: {
            // Adds an entry to the inputLineData field given the key,
            // if it doesn't already exist and returns the value,
            // otherwise returns existing value.
            //
            getInputLineData: function(key) {
                var value = this.inputLineData[key];

                if (value === undefined) {
                    value = {
                        inputLine: "",
                        prevInputLines: [],
                        prevLineIndex: []
                    };

                    this.$set(this.inputLineData, key, value);
                }

                return value;
            },

            submitAuthentication: function() {
                if ((! this.connectionState.authenticated) &&
                  (! this.connectionState.authenticationInProgress)) {
                    this.connectionState.authenticationInProgress = true;
                    this.connectionState.authenticationMessage =
                        "Authenticating...";

                    // Find the site name and set it
                    //
                    connectionState.siteName = '';

                    for (var index = 0; index < siteList.length; ++index) {
                        if (siteList[index].id == connectionState.site) {
                            connectionState.siteName = siteList[index].name ;
                            break;
                        }
                    }

                    // Once connected, it will automatically send the credentials
                    protocol.connect(connectionUrl);
                }
            },

            // Populates the input field with the previously submitted entry.
            // It can go back several lines.
            //
            goPreviousInput: function() {
                var inputInfo = this.getInputLineData(this.activeTopic.name);

                if (inputInfo.inputLine.length && inputInfo.prevLineIndex <= 0) {
                    // Don't allow going back (probably accidentally) if user
                    // is in the middle of typing.
                    return;
                }

                if (inputInfo.prevLineIndex >= 0) {
                    if (inputInfo.prevLineIndex >= inputInfo.prevInputLines.length) {
                        inputInfo.prevLineIndex = 0;
                    }

                    inputInfo.inputLine =
                        inputInfo.prevInputLines[inputInfo.prevLineIndex];
                    ++inputInfo.prevLineIndex;
                }

                var inputText = document.getElementById(
                    this.activeTopic.name + "-input-field");
                inputText.focus();
            },

            // Called to let us know we no longer have focus (window has no
            // focus, different browser tab, etc).
            //
            lostFocus: function() {
                this.displayState.hasFocus = false;
                this.displayState.textAdded = false;
            },

            // Called to let us know we have focus again.
            //
            gotFocus: function() {
                this.displayState.hasFocus = true;
                this.displayState.textAdded = false;
                document.title = origTitle;
            },

            focusOnInputLine: function() {
                var inputText = document.getElementById(
                    this.activeTopic.name + "-input-field");

                setTimeout(function() {
                    inputText.focus();
                }, 1);
            },

            // Called to send the input text to the server, put the text in
            // the previous sent lines, and clear the input line for the next
            // input.
            //
            submitText: function() {
                var inputStack =
                    this.entityTabInfo[this.activeTopic.name].inputStack;

                if (inputStack.length > 0) {
                    var inputInfo = this.getInputLineData(this.activeTopic.name);

                    // TODO Support color input
                    var textAsExternal =
                        [new ExternalPlainText(inputInfo.inputLine)];
                    inputStack[0].sendText(textAsExternal);

                    if (inputInfo.inputLine !== "") {
                        inputInfo.prevLineIndex = 0;
                        inputInfo.prevInputLines.splice(0, 0, inputInfo.inputLine);

                        if (inputInfo.prevInputLines.length > 10) {
                            inputInfo.prevInputLines.pop();
                        }
                    }

                    inputInfo.inputLine = "";
                }

                this.focusOnInputLine();
            },

            // Called when a key is pressed, this will submit the text if
            // they actually pushed enter instead.
            //
            submitEnter : function(e) {
                var keycode;

                if (e) {
                    keycode = e.keyCode;
                } else {
                    return true;
                }

                if (keycode == 13)
                {
                    // Enter pressed
                    e.preventDefault();
                    this.submitText();
                    return false;
                } else if (keycode == 38) {
                    // Up arrow pressed
                    e.preventDefault();
                    this.goPreviousInput();
                    return true;
                } else if (e.altKey && keycode === 37) {
                    // Alt-left arrow pushed.
                    e.preventDefault();
                    var keys = Object.keys(this.entityTabInfo);

                    if (keys.length === 1) {
                        // Only one entry, nothing to do.
                        return;
                    }

                    if (this.activeTopic.name === PLAYER_TOPIC) {
                        // At first puppet tab, just go to last
                        this.activeTopic.name = keys[keys.length - 1];

                        // Make sure we just didn't just go back to player
                        if (this.activeTopic.name === PLAYER_TOPIC) {
                            this.activeTopic.name = keys[keys.length - 2];
                        }
                    } else if (keys[0] === this.activeTopic.name) {
                        // At first puppet tab, just head back to player
                        this.activeTopic.name = PLAYER_TOPIC;
                    } else {
                        // Somewhere in the middle; just go back and skip over
                        // player as needed.
                        var index = keys.findIndex(function(value)
                            {return value === this.activeTopic.name});
                        --index;

                        if (keys[index] === PLAYER_TOPIC) {
                            --index;
                        }

                        if (index < 0) {
                            // At the beginning, just loop back to player
                            this.activeTopic.name = PLAYER_TOPIC;
                        } else {
                            this.activeTopic.name = keys[index];
                        }
                    }

                    this.entityTabInfo[this.activeTopic.name].activity = false;

                    this.focusOnInputLine();
                    setTimeout(function() {
                        window.scrollBy(0,10000);
                    }, 1);
                } else if (e.altKey && keycode === 39) {
                    // Alt-right arrow pushed.
                    e.preventDefault();

                    e.preventDefault();
                    var keys = Object.keys(entityTabInfo);

                    if (keys.length === 1) {
                        // Only one entry, nothing to do.
                        return;
                    }

                    if (this.activeTopic.name === PLAYER_TOPIC) {
                        // At first puppet tab, just go to next
                        this.activeTopic.name = keys[0];

                        // Make sure we just didn't just go back to player
                        if (this.activeTopic.name === PLAYER_TOPIC) {
                            this.activeTopic.name = keys[1];
                        }
                    } else if (keys[keys.length - 1] === this.activeTopic.name) {
                        // At last puppet tab, just head back to player
                        this.activeTopic.name = PLAYER_TOPIC;
                    } else {
                        // Somewhere in the middle; just advance and skip over
                        // player as needed.
                        var index = keys.findIndex(function (value) {
                            return value === this.activeTopic.name;
                        });

                        ++index;

                        if (keys[index] === PLAYER_TOPIC) {
                            ++index;
                        }

                        if (index >= keys.length) {
                            // At the end, just loop back to player
                            this.activeTopic.name = PLAYER_TOPIC;
                        } else {
                            this.activeTopic.name = keys[index];
                        }
                    }

                    this.entityTabInfo[this.activeTopic.name].activity = false;

                    this.focusOnInputLine();
                    setTimeout(function() {
                        window.scrollBy(0,10000);
                    }, 1);
                }
                else {
                    return true;
                }
            },

            // Called when an Entity is clicked.
            // This submits the request to the server, to get the description.
            //
            submitLookRequest : function(event) {
                // TODO Only allow one look sent out at a time
                if (this.descriptionData.lookId) {
                    var lookRequest = protocol.makeClientMessage("ExecuteEntity");
                    lookRequest.entityId = this.descriptionData.lookId;
                    lookRequest.programArguments =
                      [
                        "#" + event.target.attributes["entitysite"].nodeValue
                          + "-"
                          + event.target.attributes["entityid"].nodeValue
                      ];
                    lookRequest.channelSubtype = DESCRIPTION_SUBTYPE;

                    var controlChannel =
                        this.entityTabInfo[activeTopic.name].controlChannels;

                    if (controlChannel.send) {
                        controlChannel.send.sendData(lookRequest);
                    }
                }
            },

            // Called to close the description dialog
            //
            closeDescription : function() {
                this.descriptionData.descriptionChannel = null;
                this.descriptionData.descriptionReceived = false;
            },

            // Called to submit a query for what puppets the player currently
            // owns.  Used to build the puppet selection modal dialog.
            //
            submitPuppetListQuery : function() {
                var queryRequest =
                    protocol.makeClientMessage("FindEntityRequest");

                queryRequest.requestMessageId = getNextRequestId();
                queryRequest.isMessageResponse = false;
                queryRequest.searchString = "";
                queryRequest.entityType = "puppet";

                this.puppetQueryInfo.requestId = queryRequest.requestMessageId;

                var controlChannel = this.entityTabInfo.PLAYER.controlChannels;

                if (controlChannel.send) {
                    controlChannel.send.sendData(queryRequest);
                }
            },

            // Called to close the puppet dialog without adding anything
            //
            closeAddPuppet : function() {
                this.puppetQueryInfo.puppetsReceived = false;
                this.puppetQueryInfo.requestId = 0;
                this.puppetQueryInfo.puppetList = [];
            },

            // Called when Puppet is selected to add from dialog
            //
            addPuppetFromDialog : function(event) {
                var puppetId = event.target.attributes["puppetId"].nodeValue;
                var puppetName = event.target.attributes["puppetName"].nodeValue;

                var addedPuppet = {
                    blocked : true,
                    activity: false,
                    controlChannels : {
                        /** {SendChannel} */
                        send : null,
                        /** {ReceiveChannel} */
                        receive : null
                    },
                    inputStack : [],
                    name : puppetName
                };

                this.$set(this.entityTabInfo, puppetId, addedPuppet);
                this.$set(this.outputTextStore, puppetId, []);
                this.$set(this.outputIds, puppetId, []);
                // Populate input line defaults so HTML can render
                this.getInputLineData(puppetId);

                puppetQueryInfo.puppetsReceived = false;
                puppetQueryInfo.requestId = 0;
                puppetQueryInfo.puppetList = [];

                // Make sure we re-focus on text box after tabs update
                //
                setTimeout(function() {
                    var elementName = activeTopic.name + '-input-field';
                    var activeElement = document.getElementById(
                        elementName);
                    activeElement.focus();
                }, 20);

                // Send the 'ping' to open puppet channels
                //
                var puppetPing =
                    protocol.makeClientMessage("ConnectPuppetRequest");
                puppetPing.puppetEntityId =
                    new EntityId(connectionState.site, parseInt(puppetId));
                entityTabInfo[PLAYER_TOPIC].controlChannels.send.sendData(
                    puppetPing);
            },

            // Called when a tab is clicked; this will change the
            // text to that tab.
            //
            switchToEntityTab : function(event) {
                var topicName = event.target.attributes["topicName"].nodeValue;
                this.activeTopic.name = topicName;
                this.entityTabInfo[topicName].activity = false;

                this.focusOnInputLine();
                setTimeout(function() {
                    window.scrollBy(0,10000);
                }, 1);
            },

            // Called when a tab is closed; this will select another
            // tab and activate it.
            //
            closeEntityTab : function(event) {
                var topicName = event.target.attributes["topicName"].nodeValue;
                var puppetInfo = this.entityTabInfo[topicName];

                // Request the channels close
                //
                var channelsToClose =
                    [puppetInfo.controlChannels.send.id,
                     puppetInfo.controlChannels.receive.id];

                for (index = 0; index < puppetInfo.inputStack.length; ++index) {
                    channelsToClose.push(puppetInfo.inputStack[index].id);
                }

                protocol.requestChannelClose(channelsToClose);

                // Switch to player tab since that is guaranteed to be
                // there.
                //
                this.activeTopic.name = PLAYER_TOPIC;
                this.entityTabInfo[this.activeTopic.name].activity = false;

                // Remove data structures since puppet is going away
                //
                Vue.delete(this.entityTabInfo, topicName);
                Vue.delete(this.outputTextStore, topicName);
                Vue.delete(this.outputIds, topicName);
                Vue.delete(this.inputLineData, topicName);

                this.focusOnInputLine();
                setTimeout(function() {
                    window.scrollBy(0,10000);
                }, 1);
            },

            // Called when an exit is clicked.
            // This submits the request to the server, to use the exit.
            //
            useExit : function(event) {
                var useExitRequest = protocol.makeClientMessage("ExecuteEntity");
                useExitRequest.entityId = new EntityId(
                    Number(event.target.attributes["entitysite"].nodeValue),
                    Number(event.target.attributes["entityid"].nodeValue));

                var controlChannel =
                    this.entityTabInfo[activeTopic.name].controlChannels;

                if (controlChannel.send) {
                    controlChannel.send.sendData(useExitRequest);
                }
            }
        },
        created: function() {
            this.$set(this.inputLineData, PLAYER_TOPIC, {
                inputLine: "",
                prevInputLines: [],
                prevLineIndex: -1
            });

            // Put the initial two output streams in the store so FormattedTextComponent
            // can access them.
            //
            this.$set(this.outputTextStore, this.PLAYER_TOPIC, []);
            this.$set(this.outputTextStore, "descOutput", []);
            this.$set(this.outputIds, this.PLAYER_TOPIC, []);
            this.$set(this.outputIds, "descOutput", []);

            // Add player into data structures  both to serve as documentation
            // and to ensure it's ready to go since it's guaranteed to be needed.
            //
            this.$set(this.entityTabInfo, this.PLAYER_TOPIC, {
                blocked : true,
                activity: false,
                controlChannels : {
                    /** {SendChannel} */
                    send : null,
                    /** {ReceiveChannel} */
                    receive : null
                },
                inputStack : [],
                name : ""
            });
        },
        mounted: function() {
            window.onblur = this.lostFocus;
            window.onfocus = this.gotFocus;
        }
    });

    // Everything has been set up and configured.
    // This connection will trigger populating the site list.
    protocol.connect(connectionUrl);

</script>

</body>
</html>